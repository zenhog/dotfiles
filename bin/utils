#!/usr/bin/env bash

RUNSHELL="$(readlink /proc/$$/exe)"

if [[ "$RUNSHELL" == *bash* ]]; then
  RUNSHELL=bash
elif [[ "$RUNSHELL" == *zsh* ]]; then
  RUNSHELL=zsh
else
  unset RUNSHELL
fi

case "$RUNSHELL" in
  bash)
    shopt -s nullglob
    shopt -s extglob
    ;;
  zsh)
    setopt nullglob
    setopt extendedglob
    ;;
esac

function quiet() {
  "$@" 2>/dev/null
}

function silent() {
  "$@" >/dev/null
}

function mute() {
  "$@" &>/dev/null
}

function verbose() {
  local msg

  read -r msg < <(printf '[%s] %s' "$PWD" "$*")
  #NONEWLINE=1 sepline '' "$msg" >&2
  sepline >&2
  echo "$msg" >&2
  sepline '-' >&2

  if [[ -n "$DEBUG" ]]; then
    local answer
    IFS= read -r answer
    [[ -n "$answer" ]] && return 1
  fi

  "$@"
}

function checkbin() {
  for bin in "$@"; do
    silent which "$bin" || return
  done
}

function chainsource() {
  local sources

  for f in "$@"; do
    [[ -r "$f" ]] && source "$f"
  done
}

function backup() {
  for f in "$@"; do
    local rand
    read -r rand < <( tr -dc '[:alnum:]' < /dev/urandom | quiet dd bs=1 count=8)
    [[ -e "$f" ]] && verbose mv -v -- "$f" "$f.old.$rand"
  done
}

function printvars() {
  for var in "$@"; do
    echo "$var: $(eval echo \$"$var")"
  done
}

function path() {
  local fullpath dir base

  [[ -z "$1" ]] && return

  read -r fullpath < <(realpath -sm "$1")
  read -r dir  < <(dirname "$fullpath")
  read -r base < <(basename "$fullpath")

  mute realpath -se "$dir" || return

  echo "$fullpath" "$dir" "$base"
}

function sepline() {
  local columns="${FZF_PREVIEW_COLUMNS}"

  [[ -z "$columns" ]] && columns="$COLUMNS"
  [[ -z "$columns" ]] && read -r _ columns < <(quiet stty size)
  [[ -z "$columns" ]] && columns=80

  local sep="${1:-î«Œ}"
  local text="$2"

  local middle="$(($columns - ${#text}))"

  local d=$(((columns - ${#text})/2))
  local r=$(((columns - ${#text})%2))

  for _ in $(seq 1 $d); do
    printf -- "$sep"
  done

  printf "%s" "$text"

  for _ in $(seq 1 $((d + r))); do
    printf -- "$sep"
  done

  [[ -n "$NONEWLINE" ]] || echo
}

function enc() {
  gpg -q --yes --pinentry-mode=loopback --symmetric \
    --passphrase-file=<(passphrase) "$@"
}

function dec() {
  gpg -q --yes --pinentry-mode=loopback --decrypt \
    --passphrase-file=<(passphrase) "$@"
}

function passphrase() {
  declare -g PASSPHRASE

  local token="$HOME/.password-store/tokens/main.gpg"

  if [[ -z "$PASSPHRASE" ]]; then
    if [[ -z "$PROMPTPASS" ]]; then
      read -r PASSPHRASE \
        < <(quiet gpg --batch --pinentry-mode=loopback -qd "$token")
    fi

    [[ -z "$PASSPHRASE" ]] && read -r -p 'Passphrase: ' PASSPHRASE
  fi

  [[ -n "$PASSPHRASE" ]] && echo "$PASSPHRASE"
}

function emutils() {
  utils "$@"
}

if [[ "$RUNSHELL" == zsh ]]; then
  return 0 2>/dev/null
fi

function tarformat() {
  COLUMNS=80 sepline '-' "> $TAR_FILENAME <"
  cat -v -
  echo
}

function tarcreate() {
  local src dst

  read -r -a src < <(path "$1")
  read -r -a dst < <(path "$2")

  local opts=(
    --create
    --gzip
    --file "${dst:-/dev/stdout}"
    --exclude-vcs-ignores
    --sort=name
  )

  tar "${opts[@]}" -C "${src[1]}" "${src[2]}"
}

function tarextract() {
  local src opts

  read -r -a src < <(path "$1")

  opts=(
    --extract
    --gzip
    --keep-newer-files
    --preserve-permissions
    --no-same-owner
    --file "${src:-/dev/stdin}"
  )

  opts+=("${extra_opts[@]}")

  local errs=(
    '-e' 'is newer or same age'
    '-e' 'Unexpected inconsistency when making directory'
    '-e' 'Exiting with failure status due to previous errors'
  )

  coproc cat -

  exec 3>&"${COPROC[1]}"
  exec 4>&"${COPROC[0]}"
  exec {COPROC[0]}>&-
  exec {COPROC[1]}>&-

  tar "${opts[@]}" -C "${src[1]:-$PWD}" 2>&3

  exec 3>&-

  #grep -v "${errs[@]:2}" <&4 |
  #  tee >(cat > /dev/stderr) |
  #    grep -qv "${errs[@]:0:2}"

  if grep -v "${errs[@]}" <&4; then
    exec 4>&-
    return 1
  fi

  exec 4>&-
  return 0
}

function tarlist() {
  local src

  read -r -a src < <(path "$1")

  local opts=(
    --list
    --gzip
    --verbose
    --file "${src:-/dev/stdin}"
  )

  local lines

  readarray -t lines < <(tar "${opts[@]}")

  COLUMNS=80 sepline '-' '> Archive contents <'
  for line in "${lines[@]}"; do
    local mode ownership size date time path
    read -r mode ownership size date time path <<< "$line"
    echo "$mode $size $path"
  done | column -t
}

function tardump() {
  local extra_opts=(--to-command="${BASH_SOURCE[0]} tarformat")

  coproc tarextract "$@"

  exec 3>&"${COPROC[1]}"
  exec 4>&"${COPROC[0]}"
  exec {COPROC[0]}>&-
  exec {COPROC[1]}>&-

  cat "${1:-/dev/stdin}" | tee >(tarlist) >&3

  exec 3>&-
  cat <&4
  exec 4>&-
}

function tarpreview() {
  tarcreate "${1?}" | tardump
}

function tardiff() {
  local diff=diff
  tty -s && diff=delta

  if [[ "${1?}" == *.tar.gz && "${2?}" == *.tar.gz ]]; then
    "$diff" <(quiet tardump "$1") <(quiet tardump "$2")
  elif [[ -d "$1" && -d "$2" ]]; then
    "$diff" <(quiet tarpreview "$1") <(quiet tarpreview "$2")
  fi
}

function decsecret() {
  local src="$(realpath -sm "${1?}")"
  (cd "$(dirname "$src")" && dec --output - "$src" | tarextract)
}

function dumpsecret() {
  local src="$(realpath -sm "${1?}")"
  dec --output - "$src" | tardump
}

function diffsecret() {
  local dirsrc tarsrc diff=diff

  dirsrc="$(realpath -sm "${1?}")"
  tarsrc="${2:-${dirsrc}.tar.gz.gpg}"

  tty -s && diff=delta

  "$diff" \
    <(quiet dumpsecret "$tarsrc") \
    <(quiet tarpreview "$dirsrc")
}

function encsecret() {
  local src="$(realpath -sm "${1?}")"
  local dst="$src.tar.gz.gpg"

  if ! mute diffsecret "$src"; then
    if tarcreate "$src" | enc --output "$dst" -; then
      printf 'Successful encryption of %s into %s\n' "$src" "$dst" >&2
    fi
  fi
}

return 0 2>/dev/null

mute declare -F "$1" && "$@"
