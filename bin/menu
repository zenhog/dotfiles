#!/usr/bin/env bash

source "$HOME/.bin/gui"

function atexit() {
  silent declare -F atfinish && atfinish
}

BINDS[help]=alt-h
HOOKS[help]=preview
function help() {
  eval "$SDESCS"
  eval "$SBINDS"
  eval "$SGDESCS"

  sepline " Global bindings "
  for func in "${!GDESCS[@]}"; do
    echo "${BINDS[$func]} $iSEP ${GDESCS[$func]}"
  done | column -t -s "$iSEP" -o "$oSEP" | sort -k1 -r

  echo
  sepline " ${MODULE^^} bindings "

  for func in "${!DESCS[@]}"; do
    echo "${BINDS[$func]} $iSEP ${DESCS[$func]}"
  done | column -t -s "$iSEP" -o "$oSEP" | sort -k1 -r
}

BINDS[copyentry]='alt-\'
GDESCS[copyentry]='Clip entry'
function copyentry() {
  echo -n "$1" | fzf --ansi -f '' | tmux load-buffer -
}

BINDS[extract]='alt-/'
HOOKS[extract]=sclear
GDESCS[extract]='Fzfgrep preview'
function extract() {
  view "$1" | command extract 2>/dev/tty
}

BINDS[change]=change
HOOKS[change]=change
CALLS[change]='change-preview(view {})'

BINDS[paste]=alt-b
HOOKS[paste]=paste
GDESCS[paste]='Paste clipboard'
CALLS[paste]='transform-query(tmux showb)'

BINDS[eval]=btab
HOOKS[eval]=eval
GDESCS[eval]='Evaluate shell expressions'
CALLS[eval]='change-preview(eval {q})'

BINDS[qalc]=alt-bs
HOOKS[qalc]=qalc
GDESCS[qalc]='Evaluate qalc expressions'
CALLS[qalc]='change-preview(eval qalc {q})'

function inputpreview() {
  tmux show-buffer -b preview 2>/dev/null && tmux delete-buffer -b preview
}

function input() {

  local fifo query

  eval "$(IFS=\;; printf "%s" "$*")"

  local cmd

  cmd=('fzf' '--print-query')
  cmd+=('--border' 'sharp')
  cmd+=('--prompt' "input($MODULE)> ")
  cmd+=('--query' "$query")
  cmd+=('--ansi' '--reverse' '--cycle' '--no-multi')
  cmd+=('--info=inline-right')
  cmd+=('--no-separator')
  cmd+=('--preview' 'inputpreview')
  cmd+=('--preview-window' 'bottom,90%,border-top,wrap')

  if [[ -n "$fifo" ]]; then
    echo -n | "${cmd[@]}" 2>/dev/tty >"$fifo"
  else
    echo -n | "${cmd[@]}" 2>/dev/tty
  fi
}

function main() {
  trap atexit EXIT

  if [[ "$1" == input ]]; then
    export -f inputpreview
    input "${@:2}"
    return
  fi

  export MODULE="$1"

  source "$MODULES_DIR/$MODULE" || exit 1

  shift 1

  while read -r _ _ func _; do
    export -f "$func"
  done < <(declare -F) || exit 1

  read -r SBINDS < <(declare -p BINDS); export SBINDS
  read -r SHOOKS < <(declare -p HOOKS); export SHOOKS
  read -r SCALLS < <(declare -p CALLS); export SCALLS
  read -r SDESCS < <(declare -p DESCS); export SDESCS
  read -r SGDESCS < <(declare -p GDESCS); export SGDESCS

  COMMAND+=(fzf)
  COMMAND+=(--prompt="$MODULE> ")
  COMMAND+=(--border=rounded)
  COMMAND+=(--info=inline-right)
  COMMAND+=(--no-separator)
  COMMAND+=(--ansi)
  COMMAND+=(--cycle)
  COMMAND+=(--no-multi)
  COMMAND+=(--query "$*")

  if [[ -n "$PREVIEW_CMD" ]]; then
    COMMAND+=(--preview="$PREVIEW_CMD")
  elif silent declare -F view; then
    COMMAND+=(--preview="view {}")
  fi

  if silent declare -F label; then
    COMMAND+=(--bind 'load:transform-border-label:label {}')
    COMMAND+=(--bind 'focus:change-preview(view {})+transform-border-label:label {}')
  fi

  WINDOW=right,border-rounded
  EXTRA='--bind=ctrl-x:change-preview-window(bottom,border-rounded|right,border-rounded)'

  if [[ -n "$HORIZONTAL" ]]; then
    WINDOW=bottom,border-rounded
    EXTRA='--bind=ctrl-x:change-preview-window(right,border-rounded|bottom,border-rounded)'
  else
    case "$POSITION" in
      TOP)
        WINDOW=top,border-bottom ;;
      BOTTOM)
        WINDOW=bottom,border-top ;;
      LEFT)
        WINDOW=left,border-right ;;
      RIGHT)
        WINDOW=right,border-left ;;
    esac
  fi

  [[ -n "$RATIO" ]] && WINDOW+=",$RATIO" || WINDOW+=,65%

  [[ -z "$NOWRAP" ]] && WINDOW+=,wrap
  [[ -n "$FOLLOW" ]] && WINDOW+=,follow

  COMMAND+=(--preview-window="$WINDOW")

  for func in "${!BINDS[@]}"; do
    local key hook call cmd

    key="${BINDS[$func]}"

    hook="${HOOKS[$func]}"
    hook="${hook:-${CALLS[$func]}}"
    hook="${hook:-${HOOKS[default]}}"

    read -r call < <(eval printf -- '"${CALLS[$hook]}"' "$func")

    read -r cmd  < <(printf -- '--bind=%s:%s' "$key" "$call")

    COMMAND+=("$cmd")
  done

  [[ -n "$EXTRA" ]] && COMMAND+=("$EXTRA")

  mute declare -F init && init

  list "${@:2}" | "${COMMAND[@]}"
}

function dispatch() {
  local mode="$1"

  shift

  export DISPATCH_MODE="$mode"

  case "$mode" in
    input)
      local query="$*"

      local fifo="$(mktemp --dry-run --suffix=.fifo)"

      mkfifo "$fifo" && export FIFO="$fifo"

      menu loop input fifo="$fifo" query="'$query'"

      local output

      read -r output < "$fifo"

      rm -f "$fifo"

      echo "$output"
      ;;
    main)
      main "$@"
      ;;
    shell)
      if [[ -n "$TMUX" ]]; then
        tmux popup -BE -w 100% -h 100% menu main "$@"
      else
        main "$@"
      fi
      ;;
    popup)
      tmux popup -BE -w 100% -h 100% menu main "$@"
      ;;
    loop)
      socat STDIN "UNIX-CONNECT:$HOME/.menu.S" < <(IFS=:; printf "%s\n" "$*")
      ;;
    auto)
      if on_xsession; then
        exec menu loop "$@"
      else
        exec menu shell "$@"
      fi
      ;;
  esac
}

dispatch "$@"
