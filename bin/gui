#!/usr/bin/env bash

shopt -s nullglob
shopt -s extglob

export SHELL="$(which bash)"
export iSEP=$'\x01' oSEP=' âž¡ '

export MODULE="$1"
export MODULES_DIR="$HOME/.lib/gui"

source "$HOME/.bin/utils"
source "$HOME/.zshenv"

declare -A -x BINDS
declare -A -x DESCS
declare -A -x GDESCS
declare -A -x HOOKS=([default]=qclear)
declare -A -x CALLS=(
	[accept]='execute-silent(do_call %s {} {q})+accept'
	[acceptsync]='execute(do_call %s {} {q})+accept'
	[qclear]='execute-silent(do_call %s {} {q})+reload-sync(list)+clear-query'
	[sclear]='execute(do_call %s {} {q})+clear-screen+reload-sync(list)'
	[clear]='execute(do_call %s {} {q})+clear-screen+reload-sync(list)+clear-query'
	[noclear]='execute-silent(do_call %s {} {q})+reload-sync(list)'
	[preview]='change-preview(do_call %s {} {q})'
)

function do_call() {
	local func="$1"
	local entry="$(filter all "$2")"
	local query="$(filter all "$3")"

	"$func" "$entry" "$query"
}

function preview() {
	mute declare -F view && do_call view "$1" "$2"
}

function filter() {
	local kind="$1" input="$2"

	case "$kind" in
	unprintable)
		# filters out unprintable and multicell chars like nerdfont icons
		perl -pe 's|^[^[:graph:]].*?[ ]||p' <<<"$input"
		;;
	ansicolors)
		# filters out ansi color sequences and more?
		sed 's/\x1b\[[0-9;]*[mGKHF]//g' <<<"$input"
		;;
	all)
		local out="$input"

		out="$(filter unprintable "$out")"
		out="$(filter ansicolors "$out")"

		echo "$out"
		;;
	esac
}

function notify() {
	silent notify-send -t 5000 -a menu "$MODULE" "$@"
	widget push timeout
}

function get_opt() {
	quiet tmux show -sv "@menu-${MODULE}-$1"
}

function set_opt() {
	quiet tmux set -s "@menu-${MODULE}-$1" "$2"
}

function unset_opt() {
	quiet tmux set -su "@menu-${MODULE}-$1"
}

function list_opt() {
	quiet tmux show -s | grep "^@menu-${MODULE}"
}

function save_opt() {
	local val

	read -r val < <(get_opt "$1")

	if [[ -n "$val" ]]; then
		set_opt "$1-saved" "$val"
	fi
}

function restore_opt() {
	local val

	read -r val < <(get_opt "$1-saved")

	if [[ -n "$val" ]]; then
		set_opt "$1" "$val"
		unset_opt "$1-saved"
	fi
}

function toggle_opt() {
	local opt="$1"
	local val="$(get_opt "$opt")"

	val="${val:-0}"

	case "$val" in
	0) set_opt "$opt" 1 ;;
	1) set_opt "$opt" 0 ;;
	esac
}

function rotate_opt() {
	local val="$(get_opt "$1")"
	local mod="$(get_opt "$1-mod")"

	[[ -z "$val" || -z "$mod" ]] && return

	set_opt "$1" $((++val % mod))
}

return 0 2>/dev/null

case $# in
0) # list modules
	readarray -t modules < <(realpath $MODULES_DIR/*)
	readarray -t modules < <(basename -a "${modules[@]}")
	for mod in "${modules[@]}"; do
		unset ICON MOD KEY
		source "$MODULES_DIR/$mod"
		[[ -n "$KEY" ]] && printf "%s:%s:%s:%s\n" "$ICON" "$mod" "$MOD" "$KEY"
	done
	;;
1) # list module functions
	source "$MODULES_DIR/$1" || exit 1
	#declare -F | awk '{print $3}'
	for f in "${!BINDS[@]}"; do
		echo "$f"
	done
	;;
*) # call module functions
	source "$MODULES_DIR/$1" || exit 1
	[[ "$2" == inspect ]] && declare -f "$3" || "${@:2}"
	;;
esac
