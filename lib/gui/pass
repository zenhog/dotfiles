#!/usr/bin/env bash

KEY=p
MOD='S-M'
ICON=󰍁
COLOR=springgreen

NOWRAP=1
RATIO=65

export STORE="$HOME/.password-store"

atfinish() {
  mute tmux delete-buffer -b location
}

label() {
	quiet tmux show-buffer -b location
}

extract() {
	view "$1" | command extract GR_PASSVAL 2>/dev/tty
}

view() {
  local id dir tag dom ind

  read -r id dir tag dom ind <<< "$1"

  local path="$id/$dir/$tag/$dom/$ind"

	local entries

	readarray -t entries < <(cd "$STORE/$path" && find -- * -type f)

	local val
	for entry in "${entries[@]}"; do
		unset val

		if [[ "$entry" == *.gpg ]]; then
			read -r val < <(quiet pass show "$path/${entry%.gpg}")
		else
			read -r val <"$STORE/$path/$entry"
		fi

		if [[ "$entry" == password* ]]; then
			local charspec

			read -r charspec < <(get "$path" charspec)

			if silent check "$val" "$charspec"; then
				read -r val < <(colorize green "$val")
			else
				read -r val < <(colorize red "$val")
			fi
		fi

    if [[ "$entry" == location* ]]; then
      local newloc

      IFS= read -r newloc < <(quiet tmux show-buffer -b location)
 
      if [[ -n "$newloc" && "$newloc" == "$val" ]]; then
        read -r val < <(colorize green "$val")
      elif [[ -n "$newloc" && "$newloc" != "$val" ]]; then
        read -r val < <(colorize red "$val")
      fi
    fi

    if [[ "$entry" == *.gpg ]]; then
      read -r entry < <(colorize cyan "${entry%.gpg}")
    else
      read -r entry < <(colorize yellow "${entry}")
    fi

		printf "%s%s%s\n" "$entry" "$iSEP" "$val"
	done | column -t -s "$iSEP" -o "$oSEP"
	echo
	#qrencode -m1 -tANSI256 <<< "$val"
}

OPTS+=(--header-lines=1)
list() {
  local entries
  readarray -t entries < <(
	cd "$STORE" && find -- * \( -type d -or -type l \) -exec sh -c \
		'test -z "$(find "{}" -mindepth 1 -type d)" && echo {}' \; | sort)

  local id dir tag dom ind

  for entry in "${entries[@]}"; do
    IFS=/ read -r id dir tag dom ind <<< "$entry"
    printfmt \
      "$(colorize cyan "$id")" \
      "$(colorize red "$dir")" \
      "$(colorize yellow "$tag")" \
      "$(colorize green "$dom")" \
      "$(colorize magenta "$ind")"
  done | column -t -s "$iSEP" -N ID,DIR,TAG,DOM,IND -R DOM
}

rename() {
	local rand file="$STORE/$1.gpg"
	read -r rand < <(tr -dc '[:alnum:]' </dev/urandom | quiet dd bs=1 count=5)
  [[ -f "$file" ]] && mv -v -- "$file" "${file%.gpg}.old.$rand.gpg"
}

get() {
	local dir="$1" key="$2"
	quiet pass show "$dir/$key" || quiet cat "$STORE/.defaults/$key"
}

insert() {
	local dir="$1" key="$2" val="$3" curval

	[[ -z "${key?}" ]] && return 1

	read -r curval < <(get "$dir" "$key")

	[[ "$val" == "$curval" ]] && return 0

	pass insert -f "$dir/$key" < <(tee /dev/stdout <<<"$val")
}

check() {
	local password="${1}" charspec="${2}" length count specs regex

	[[ -n "${password}" && -n "${charspec}" ]] || return 1

	{
		read -r -d, length
		IFS=$',\n' readarray -d, -t -s 0 specs
	} <<<"${charspec}" || return 1

	read -r count < <((grep -o '.' | wc -l) <<<"$password")

	((count == length)) || return 1

	for spec in "${specs[@]}"; do
		local count class length
		IFS=$'|\n' read -r -d '' length class _ <<<"$spec"
		read -r count < <((grep -o "[${class}]" | wc -l) <<<"$password")
		((count >= length)) || return 1
	done

	read -r regex < <(printf "%s" "${specs[@]#*|}")

	grep -o "[^${regex}]" <<<"$password" && return 1 || return 0
}

BINDS[regen]=alt-r
HOOKS[regen]=noclear
DESCS[regen]='Regenerate password conform to spec'
regen() {
	local dir="$1" password charspec length specs regex

	read -r charspec < <(get "${dir}" charspec)
	{
		read -r -d, length
		IFS=$',\n' readarray -t -s 0 specs
	} <<<"${charspec}" || return 1

	mkdir -p "${STORE}/${dir}"

	silent pass show "${dir}/password" && rename "${dir}/password"

	read -r regex < <(printf "%s" "${specs[@]#*|}")

	until check "${password}" "${charspec}"; do
		PASSWORD_STORE_CHARACTER_SET="${regex}" \
			command pass generate -f "${dir}/password" "${length}"
		read -r password < <(quiet pass show "${dir}/password")
	done
}

BINDS[reloc]=alt-u
HOOKS[reloc]=noclear
DESCS[reloc]='Overwrite location'
reloc() {
	local entry="${1?}"

  read -r newloc < <(quiet tmux show-buffer -b location)

	if [[ -n "$newloc" ]]; then
		rename "$entry/location"
		insert "$entry" location "$newloc"
	fi
}

BINDS[cleanup]=alt-c
HOOKS[cleanup]=noclear
DESCS[cleanup]='Clean old password entries'
cleanup() {
	local dir="$1"
	[[ -d "${STORE}/${dir}" ]] && rm -f "${STORE}/${dir}"/*.old.*.gpg
}

BINDS[mod]=alt-w
HOOKS[mod]=sclear
DESCS[mod]='Modify entries'
mod() {
	local dir="$1" entries

	view "$dir" | tmux load-buffer -b preview -

  readarray -t entries < <(readeval < <(input))

	mute tmux delete-buffer -b preview

	for entry in "${entries[@]}"; do
    IFS=: read -r key val <<< "$entry"
    if [[ -z "$val" ]]; then
      rename "$dir/$key"
      continue
    fi
    rename "$dir/$key"
    insert "$dir" "$key" "$val"
	done
}

BINDS[edit]=alt-e
HOOKS[edit]=sclear
DESCS[edit]='Rename directory entry'
edit() {
	local dir="$1" newdir

	view "$dir" | tmux load-buffer -b preview -

	read -r newdir < <(input ghost="$dir" query="$dir")

	tmux delete-buffer -b preview

	[[ ! -d "$STORE/$newdir" ]] &&
		(mkdir -p "$STORE/$newdir" && mv -Tvf -- "$STORE/$dir" "$STORE/$newdir")
}

BINDS[getuser]=alt-t
HOOKS[getuser]=accept
DESCS[getuser]='Clip username field'
getuser() {
	local dir="$1"
	quiet get "$dir" username | tmux load-buffer -
}

BINDS[getpass]=alt-y
HOOKS[getpass]=accept
DESCS[getpass]='Clip password field'
getpass() {
	local dir="$1"
	quiet get "$dir" password | tmux load-buffer -
}

BINDS[add]=alt-a
HOOKS[add]=sclear
DESCS[add]='Add directory entry'
add() {
	local entry="$1"

	read -r entry < <(input query="${entry:-0/www/}")

  mkdir -p "$STORE/$entry"
}

BINDS[del]=alt-d
HOOKS[del]=noclear
DESCS[del]='Remove directory entry'
del() {
	local dir="${1}"

	rm -rf "${STORE}/${dir}"
	(cd "$STORE" && find -- * -type d -empty -delete)
}

dom() {
	local IFS='.' i=0 matches

	local zones=($@)

	while [[ $i -lt $((${#zones[@]} - 1)) ]]; do
		readarray -t matches < <(cd "$STORE" &&
      find -- * \( -type d -or -type l \) -name "*${zones[*]:$i}")

		[[ -n "$matches" ]] && break

		((++i))
	done

	printf "%s\n" "${matches[@]}"
}

baseurl() {
	local IFS='.'

	local zones=($@)

	if [[ ${#zones[@]} -gt 2 ]]; then
		local chunks=(${zones[-1]})
		local i=2
		while [[ $i -le ${#zones[@]} ]]; do
			chunks=("${zones[-$i]}" "${chunks[@]}")
			[[ ${#zones[-$i]} -ge 4 ]] && break
			((i++))
		done
		zones=(${chunks[@]})
	fi

	printf "www/%s\n" "${zones[*]}"
}

grab() {
	local domain="$1" key="$2" index="$3" dirs

  readarray -t entries < <(dom "$domain")

  (( ${#entries[@]} == 0 )) && {
    notify "No entry found for '$domain'"
    return 1
  }

  local entry

  if [[ -z "$index" ]]; then
    {
      read -r _
      read -r entry _
    } < <(quiet menu input "${entries[@]}")
  else
    entry="${entries[$((index-1))]}"
  fi

  read -r entry < <(quiet get "$entry" "$key")

  if [[ -n "$entry" ]]; then
    echo "$entry"
		notify "Copied '$entry/$key'"
    return 0
  fi

  notify "Could not find entry '$domain/$key'"
  return 1
}

BINDS[open]=enter
HOOKS[open]=accept
DESCS[open]='Open location entry'
open() {
	local location dir="$1"

	read -r location < <(get "$dir" location)

	command open "$location"
}

BINDS[bgopen]=tab
HOOKS[bgopen]=noclear
DESCS[bgopen]='Open location entry in the background'
bgopen() {
	open "$@"
}

BINDS[fopen]=alt-enter
HOOKS[fopen]=clear
DESCS[fopen]='Open location entry'
fopen() {
	local location dir="$1"

	read -r location < <(get "$dir" location)

	urlopen "$location"
}

new() {
  local dom="${1?}" loc="${2?}" index="${3:-0}"

  local entry entries

  readarray -t entries < <(dom "$dom")

  if [[ -z "${entries[$index]}" ]]; then
    read -r entry < <(baseurl "$dom")
  else
    entry="${entries[$index]}"
  fi

  [[ -z "$entry" ]] && read -r entry < <(baseurl "$dom")

  entry="$index/$entry"

  local path="$STORE/$index/$entry"

  echo -n "$loc" | tmux load-buffer -b location -

  [[ -d "$path" ]] && exec menu auto "$MODULE" -- "$entry"

	list | tmux load-buffer -b preview -

  read -r entry < <(menu input "ghost=$entry" "query=$entry")

	tmux delete-buffer -b preview

  if [[ -n "$entry" ]]; then
    insert "$entry" location "$loc"
    regen "$entry"
    notify "Initialized entry '$entry'"
  fi

  [[ -n "$entry" ]]
}
