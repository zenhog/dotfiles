#!/usr/bin/env bash

KEY=u
MOD='S-M'
ICON=ï‘¡

HORIZONTAL=1

export DB="$HOME/.db/bookmarks.db"
export DB="$HOME/.db/marks.db"

function initdb() {
  sqlite3 "$DB" << EOF
    CREATE TABLE IF NOT EXISTS bookmarks (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      url TEXT NOT NULL UNIQUE,
      title TEXT NOT NULL,
      category_id INTEGER NOT NULL,
      FOREIGN KEY (category_id) REFERENCES categories (id)
    );
    CREATE UNIQUE INDEX bookmarks_index ON bookmarks (title);
    CREATE TABLE IF NOT EXISTS categories (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL UNIQUE
    );
    CREATE UNIQUE INDEX categories_index ON categories (name);
    CREATE TABLE IF NOT EXISTS tags (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL UNIQUE
    );
    CREATE UNIQUE INDEX tags_index ON tags(name);
    CREATE TABLE IF NOT EXISTS bookmark_tags (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      bookmark_id INTEGER NOT NULL,
      tag_id INTEGER NOT NULL,
      FOREIGN KEY (bookmark_id) REFERENCES bookmarks (id),
      FOREIGN KEY (tag_id) REFERENCES tags (id)
    );
    CREATE UNIQUE INDEX bookmark_tags_index ON bookmark_tags (bookmark_id);
    CREATE UNIQUE INDEX tag_bookmarks_index ON bookmark_tags (tag_id);
EOF

  local tags=(
    linux bash windows programming c cpp ruby c++ web git github gitlab
    kubernetes ansible devops cicd google cloud cli security hacking dev
    python kernel shell zsh aws gke eks aks voidlinux freebsd openbsd bsd
    vmware virtualization libvirt
  )

  local categories=(
    WIKI POST FAQ SUB LIST QREF SVC NEWS
    GUIDE HELP DOC GIST SITE BLOG REPO
  )

  insert categories "${categories[@]}"
  insert tags "${tags[@]}"
}

function insert() {
  local kind="$1"

  shift

  case "$kind" in
    categories)
      for c in "$@"; do
        sqlite3 "$DB" "INSERT INTO categories (name) VALUES ('$c')"
      done
      ;;
    tags)
      for t in "$@"; do
        sqlite3 "$DB" "INSERT INTO tags (name) VALUES ('$t')"
      done
      ;;
    bookmark)
      local url="$1" title="$2" category="$3" cat_id bookmark_id
      read -r cat_id < <(getid category "$category")
      sqlite3 "$DB" "
        INSERT INTO bookmarks (url, title, category_id)
        VALUES ('$url', '$title', $cat_id)
      "
      shift 3
      read -r bookmark_id < <(getid bookmark "$url")
      for t in "$@"; do
        local tag_id
        read -r tag_id < <(getid tag "$t")
        sqlite3 "$DB" "
          INSERT INTO bookmark_tags (bookmark_id, tag_id)
          VALUES ($bookmark_id, $tag_id)
        "
      done
      ;;
  esac
}

function getid() {
  local kind="$1"
  local name="$2"

  shift 2

  case "$kind" in
    tag)
      mute insert tags "$name"
      quiet sqlite3 "$DB" "SELECT id FROM tags WHERE name == '${name}'"
      ;;
    category)
      insert categories "$name"
      sqlite3 "$DB" "SELECT id FROM categories WHERE name == '${name}'"
      ;;
    bookmark)
      sqlite3 "$DB" "SELECT id FROM bookmarks WHERE url == '${name}'"
      ;;
  esac
}

function view() {
  local id

  read -r -d ' ' id dummy <<< "$1"

  sqlite3 "$DB" "select url from bookmarks where id == $id"
  sepline
  #sqlite3 "$DB" "select metadata from bookmarks" | sed -r 's/[[:blank:][:punct:]]/\n/g' |
  #  sort -u | fmt --width="$FZF_PREVIEW_COLUMNS"
}

function printdb() {
  local query="$1"
  case "$query" in
    titles)
      sqlite3 "$DB" "SELECT title FROM bookmarks" | sort -u
      ;;
    categories)
      sqlite3 "$DB" "SELECT category FROM bookmarks" | sort -u
      ;;
    tags)
      sqlite3 "$DB" "SELECT tags FROM bookmarks" | sort -u
      ;;
    info)
      local cats tags
      readarray -t cats < <(printdb categories)
      readarray -t tags < <(printdb tags)

      ;;
  esac
}

function list() {
  sqlite3 -separator "$iSEP" "$DB" "
    SELECT bookmarks.id, categories.name, bookmarks.title, x.name FROM
    bookmarks
    INNER JOIN categories ON bookmarks.category_id = categories.id
    INNER JOIN (
      SELECT bookmark_tags.bookmark_id, tags.name FROM bookmark_tags
      INNER JOIN tags ON bookmark_tags.tag_id = tags.id
    ) x ON x.bookmark_id = bookmarks.id
    ORDER_BY categories.name
  " | column -t -s "$iSEP"
  # format: CATEGORY title (#hashtags)
}

BINDS[open]=enter
HOOKS[open]=accept
DESCS[open]='Open bookmark'
function open() {
  local id url
  read -r id _ <<< "$1"
  read -r url < <(sqlite3 "$DB" "select url from bookmarks where id == $id")
  command open "$url"
}

BINDS[copy]=alt-c
DESCS[copy]='Clipboard bookmark URL'
function copy() {
  local id url
  read -r id _ <<< "$1"
  read -r url < <(sqlite3 "$DB" "select url from bookmarks where id == $id")
  tmux load-buffer - <<< "$url"
}

function check() {
  local id
  read -r id < <(sqlite3 "$DB" "SELECT id FROM bookmarks WHERE url == '$1'")
}

BINDS[rm]=alt-d
DESCS[rm]='Delete bookmark'
function rm() {
  local id
  read -r id _ <<< "$1"
  sqlite3 "$DB" "DELETE FROM bookmarks WHERE id == $id"
}

BINDS[mod]=alt-e
HOOKS[mod]=sclear
DESCS[mod]='Rename bookmark'
function mod() {
  local id title
  read -r id title <<< "$1"

  echo -n "$title" | tmux load-buffer -b preview -

  read -r title < <(input)

  mute tmux delete-buffer -b preview

  if [[ -n "$title" ]]; then
    sqlite3 "$DB" \
      "UPDATE bookmarks SET metadata = '${title}' WHERE id ==  ${id}"
  fi
}

function parse() {
  local cat tags title

  read -r -a text <<< "$1"

  cat="${text[0]}"

}

function add() {
  local url="$1"

  if check "$url"; then
    notify "'$url' already exists"
    exit 1
  fi

  sqlite3 "$DB" "SELECT metadata FROM bookmarks" | tmux load-buffer -b preview -

  local title="$(menu input)"

  [[ -n "$title" ]] && sqlite3 "$DB" \
    "INSERT INTO bookmarks (url, metadata) values ('$url', '$title')"

  if check "$1"; then
    notify "Added '$url'"
  else
    notify "Failed to add '$url'"
  fi
}


function del() {
  local url="$1"
  if check "$url"; then
    sqlite3 "$DB" "DELETE FROM bookmarks where url == '$1'"
    if check "$url"; then
      notify "Failed to delete '$url'"
    else
      notify "Deleted '$url'"
    fi
  else
    notify "'$url' does not exist"
  fi
}
