#!/usr/bin/env bash

KEY=t
MOD='S-M'
ICON=
ALTICON=
COLOR=yellow

HORIZONTAL=1

NOWRAP=1

click() {
  awesome-client "require('commands').layout()"
}

iconupdate() {
  local module="$1"
  local icon="$2"

  call "require('commands').updateicon('$module', '$icon')"
}

OPTS+=(--with-nth 1.. --header-lines=1)
list() {
  local entries args
  local keys=(window pid tagnum profile class instance name)

  args=("${keys[@]/#/\'}")
  args=("${args[@]/%/\'}")

  read -r args < <(IFS=,; printf "%s" "${args[*]}")

  readarray -t entries < <(awm "list($args)")

  printf "%s\n" "${entries[@]}" | sort -k3 -t "$iSEP" |
    column -t -s "$iSEP" -N "$(IFS=,; printf "%s" "${keys[*]^^}")"
}

view() {
	local wid lines

	read -r wid _ <<< "$1"

  properties @window="$wid"
}

BINDS[open]=enter
HOOKS[open]=accept
DESCS[open]='Raise window entry'
open() {
	local wid

	read -r wid _ <<< "$1"

	raise @window="$wid"
}

BINDS[close]=alt-d
DESCS[close]='Close window entry'
close() {
	local window

	read -r window _ <<<"$1"
	winkill @window="$window"
}

call() {
  local retval lines code="$*"

  IFS=$'\n' read -r -d '' -a lines < <(awesome-client "require('awful'); $code")

  if [[ ${#lines[@]} -eq 1 ]]; then
    read -r type retval <<< "${lines[0]}"
    retval="${retval#\"}"
    retval="${retval%\"}"
    echo "$retval"
    [[ "$lines" =~ false ]] && return 1 || return 0
  fi

  printf "%s\n" "${lines[@]:1:$((${#lines[@]} - 2))}"
  return 0
}

awm() {
  local args="$*"

  call "return require('awm').${args}"
}

inspect() {
  awm 'inspect()'
}

fmt() {
  local args

  for arg in "$@"; do
    if [[ "$arg" == *=* ]]; then
      IFS=$'=' read -r lhs rhs <<< "$arg"
      if [[ '@' == "${lhs:0:1}" ]]; then
        lhs="${lhs:1}"
      else
        rhs="'$rhs'"
      fi
      args+=("'$lhs'" "$rhs")
    else
      args+=("'$arg'")
    fi
  done

  read -r args < <(IFS=,; printf "%s" "${args[*]}")

  echo -n "$args"
}

raise() {
  fg "$@"
}

dispatch() {
  local callback="$1"

  shift

  local args

  read -r args < <(fmt "$@")

  awm "${callback}($args)"
}

winkill() {
  dispatch kill "$@"
}

timeout() {
  dispatch timeout "$@"
}

properties() {
	getattributes "$@" -- \
    valid \
    iconpath \
    startup_id \
    type \
    role \
    minimized \
    hidden \
    urgent \
    sticky \
    ontop \
    fullscreen \
    maximized \
    opacity \
    transparency
}

getattributes() {
  dispatch getattributes "$@"
}

setattributes() {
  dispatch setattributes "$@"
}

exists() {
	mute getattributes "$@" -- window
}

fg() {
  spawn fg "$@"
}

bg() {
  spawn bg "$@"
}

parse() {
	local lhs rhs side=lhs type="$1"

	shift

	for item in "$@"; do
		if [[ "$item" == "--" ]]; then
			side=rhs
			continue
		fi

		[[ "$side" == lhs ]] && lhs+=("$item")
		[[ "$side" == rhs ]] && rhs+=("$item")
	done

	case "$type" in
	lhs) printf -- "%s\n" "${lhs[@]}" ;;
	rhs) printf -- "%s\n" "${rhs[@]}" ;;
	esac
}

spawn() {
	local mode="$1"

	shift

	local lhs rhs attrs

	readarray -t lhs < <(parse lhs "$@")
	readarray -t rhs < <(parse rhs "$@")

  local args=("${rhs[@]:1}")

  read -r attrs < <(fmt "${lhs[@]}")

  local cmd=("${rhs[0]}" "${args[@]@Q}")

  read -r cmd < <(IFS=' '; printf "%s" "${cmd[*]}")

  if [[ -z "$attrs" ]]; then
    awm "$mode(\"$cmd\")"
  else
    awm "$mode(\"$cmd\", ${attrs})"
  fi
}
