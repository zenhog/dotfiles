#!/usr/bin/env bash

KEY=i
MOD='S-M'
ICON=Û∞ê∞

HORIZONTAL=1

init() {
	set_opt mode sinks
}

label() {
	local mode="$(get_opt mode)"

	echo " mode: $mode "
}

BINDS[rotate_mode]=alt-t
HOOKS[rotate_mode]=clear
DESCS[rotate_mode]='Rotate mode'
rotate_mode() {
	local mode="$(get_opt mode)"

	case "$mode" in
	sinks) set_opt mode sources ;;
	sources) set_opt mode sink-inputs ;;
	sink-inputs) set_opt mode source-outputs ;;
	source-outputs) set_opt mode sinks ;;
	esac
}

view() {
	local index

	read -r index _ <<<"$1"

	local mode="$(get_opt mode)"

	set_opt mode "$mode"

	pactl -f json list "$mode" | jq ".[] | select(.index == ${index})" | yq -yC
}

BINDS[inc]=alt-k
DESCS[inc]='Volume Up'
inc() {
	volctl + "$@"
}

BINDS[dec]=alt-j
DESCS[dec]='Volume Down'
dec() {
	volctl - "$@"
}

volctl() {
	local index ctl="$1"

	shift

	read -r index _ <<<"$1"

	local mode="$(get_opt mode)"

	set_opt mode "$mode"

	pactl set-"${mode%s}"-volume "$index" "${ctl}5%"

	widget playback timeout
	widget capture timeout
}

BINDS[togglemute]=alt-r
DESCS[togglemute]='Toggle Mute'
togglemute() {
	local index

	read -r index _ <<<"$1"

	local mode="$(get_opt mode)"

	set_opt mode "$mode"

	case "$mode" in
	sinks)
		mode=sink
		;;
	sources)
		mode=source
		;;
	esac

	pactl set-"$mode"-mute "$index" toggle

	widget playback timeout
	widget capture timeout
}

# input
# output
# source
# sink

# set-default
# set-sink-source

# vol %5+
# vol %5-
# vol toggle
# vol mute/unmute

# edit conn
# show conn
# add wifi
# mod sublist
#   pass
#   name
#   forget?

# create aec-sink-source
# create drc-sink-source
# create surround-sink
# create combine-sink-all
# create monitored-sink?

list() {
	# format: INDEX, SINK/SOURCE/INPUT/OUTPUT/PORT, NAME, MUTE, VOL, DEFAULT

	local mode="${1:-$(get_opt mode)}"

	set_opt mode "$mode"
	entries "$mode"
}

entries() {
	local kind="$1"
	local json="$(pactl -f json list "$kind")"

	local indices descs lvols rvols mutes dsource dsink default

	read -r dsink < <(pactl get-default-sink)
	read -r dsource < <(pactl get-default-source)

	readarray -t indices < <(jq -r '.[] | (.index|tostring)' <<<"$json")

	case "$kind" in
	sinks | sources)
		readarray -t names < <(jq -r '.[] | .name' <<<"$json")
		readarray -t descs < <(jq -r '.[] | .description' <<<"$json")
		readarray -t lvols < \
			<(jq -r '.[] | .volume."front-left".value_percent' <<<"$json")
		readarray -t rvols < \
			<(jq -r '.[] | .volume."front-right".value_percent' <<<"$json")
		readarray -t mutes < <(jq -r '.[] | .mute' <<<"$json")

		mutes=("${mutes[@]/true/M}")
		mutes=("${mutes[@]/false/-}")

		unset default

		case "$kind" in
		sinks)
			default="$dsink"
			;;
		sources)
			default="$dsource"
			;;
		esac

		for i in "${!indices[@]}"; do
			read -r line < <(printf "%s%s[%s:%s]%s%s" \
				"${indices[$i]}" "$iSEP" "${lvols[$i]}" "${mutes[$i]}" \
				"$iSEP" "${descs[$i]}")
			if [[ "${names[$i]}" == "$default" ]]; then
				printf "%s\n" "$(colorize green "$line")"
			else
				printf "%s\n" "$line"
			fi
		done | column -t -s "$iSEP"
		;;
	sink-inputs | source-outputs)
		readarray -t descs < <(jq -r '.[] | .properties."media.name"' <<<"$json")
		readarray -t names < \
			<(jq -r '.[] | .properties."application.name"' <<<"$json")
		readarray -t lvols < \
			<(jq -r '.[] | .volume."front-left".value_percent' <<<"$json")
		readarray -t rvols < \
			<(jq -r '.[] | .volume."front-right".value_percent' <<<"$json")
		readarray -t mutes < <(jq -r '.[] | .mute' <<<"$json")

		mutes=("${mutes[@]/true/M}")
		mutes=("${mutes[@]/false/-}")

		for i in "${!indices[@]}"; do
			printf "%s%s[%s:%s]%s%s (%s)\n" \
				"${indices[$i]}" "$iSEP" "${lvols[$i]}" "${mutes[$i]}" \
				"$iSEP" "${names[$i]}" "${descs[$i]}"
		done | column -t -s "$iSEP"
		;;
	esac
}
