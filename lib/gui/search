#!/usr/bin/env bash

KEY=s
MOD='S-M'
ICON=ï€‚
COLOR=moccasin

NOWRAP=1

export UEBERZUG_PREVIEW=1

init() {
	set_opt pwd "$HOME/.marks"
	# [[ -n "$(get_opt pwd)" ]] || set_opt pwd "$HOME/.marks"
	set_opt hide hidden
	set_opt mode dirs
}

folder_save() {
	set_opt pwd "$(pwd)"
}

folder_restore() {
	FOLDER="$(get_opt pwd)"
}

path() {
	local path="$(filter all "$1")"

	folder_restore

	if [[ "${path:0:1}" == / ]]; then
		realpath -s "$path"
	else
		realpath -s "$FOLDER/$path"
	fi
}

folder_cd() {
	cd "$(path "$1")" && folder_save
}

label() {
	local path="$(path "$FOLDER")"
	local mode="$(get_opt mode)"
	local hide="$(get_opt hide)"
  local save="$(get_opt save)"
  local base="$(get_opt path)"

  local flags=''

  [[ "$mode" == dirs ]] && flags+='D' || flags='-'
  [[ "$hide" == visible ]] && flags+='.' || flags+='*'
  [[ "$save" == 1 ]] && flags+='+' || flags+=' '

  printf '[%s]' "$path"
  printf '[%s]' "$flags"
  if [[ -n "$base" ]]; then
    printf "[%s]" "$(basename "$base")"
  fi

}

mimetype() {
	# assuming valid absolute path
	local path="$(path "$1")"

	printf "%s (%s - %s)\n" "$path" "$(file -bL --mime-type "$path")" \
		"$(du -hs "$path" | awk '{print $1}')"
}

view() {
	local path="$(path "$1")"

	mimetype "$path"
	sepline
	command preview "$path"
}

state_update() {
	folder_restore
	restore_opt hide
}

BINDS[list]=alt-w
DESCS[list]='Reload current directory listing'
OPTS+=(--multi)
list() {
  local dir="$(get_opt altdir)"

  if [[ $# -gt 0 ]]; then
    set_opt mult "$1"
    set_opt dir "$2"
    set_opt save "$3"
    set_opt path "$4"
    set_opt out "$5"
  fi

  local lsd_opts

	state_update

  local hide="$(get_opt hide)"

  case "$hide" in
    hidden)
      lsd_opts=()
      ;;
    visible)
      lsd_opts=('-A')
      ;;
  esac

	if [[ -n "$dir" ]]; then
		folder_cd "$dir" && folder_restore
    unset_opt altdir
	fi

  lsd -1 --no-symlink --group-dirs=first "${lsd_opts[@]}" "$FOLDER/"
}

BINDS[choose]=alt-i
HOOKS[choose]=choose
CALLS[choose]='execute-silent(choose {q} {+})+accept'
DESCS[choose]='Choose file or directory'
choose() {
  local query="$1"
  shift

  local items

  for entry in "$@"; do
    items+=("$(path "$entry")")
  done

  local save="$(get_opt save)"
  local path="$(get_opt path)"
  local out="$(get_opt out)"
  local mult="$(get_opt mult)"
  local dir="$(get_opt dir)"

  # rm -f "$out"

  if [[ "$save" == 1 ]]; then
    local base=$(basename "$path")

    if [[ -n "$query" ]]; then
      base="$query"
    fi

	  folder_restore

    touch "$FOLDER/$base"
    echo "$FOLDER/$base" > "$out"

    return 0
  fi

  if [[ "$dir" == 1 ]]; then
    if [[ -d "$items" ]]; then
      echo "$items" > "$out"
      return 0
    fi
  fi

  if [[ "$mult" == 1 ]]; then
    for item in "${items[@]}"; do
      if [[ -r "$item" ]]; then
        echo "$item" >> "$out"
      fi
    done
  else
      [[ -f "$items" ]] && echo "$items" > "$out"
  fi
}

BINDS[search]=alt-s
HOOKS[search]=search
CALLS[search]='reload-sync(%s)+clear-query'
DESCS[search]='Search arbitrary pattern with fd'
search() {
	state_update

  local mode="$(get_opt mode)"

  local fd_opts

  case "$mode" in
    dirs)
      fd_opts=(-td)
      ;;
    files)
      fd_opts=(-tf)
      ;;
  esac

  fd --base-directory "$FOLDER" --color=always -L "${fd_opts[@]}"
}

BINDS[rotate_mode]=alt-y
DESCS[rotate_mode]='Rotate mode'
rotate_mode() {
  local mode="$(get_opt mode)"

  case "$mode" in
    dirs)
      set_opt mode files
      ;;
    files)
      set_opt mode dirs
      ;;
  esac
}

BINDS[toggle_hide]=alt-t
DESCS[toggle_hide]='Toggle hidden'
toggle_hide() {
  local hide="$(get_opt hide)"

  case "$hide" in
    hidden)
      set_opt hide visible
      ;;
    visible)
      set_opt hide hidden
      ;;
  esac
}

BINDS[rename]=alt-r
HOOKS[rename]=sclear
DESCS[rename]='Prompt rename entry'
rename() {
	folder_restore
	local entry="$1"

	read -r input < <(cd "$FOLDER" && input ghost="'$entry'" query="'$entry'")
	mv -- "$FOLDER/$entry" "$FOLDER/$input"
}

BINDS[mark]=alt-m
DESCS[mark]='Mark entry'
mark() {
	local path="$(path "$1")"

	local marksdir="$HOME/.marks"

	local target="$(realpath -m --relative-to="$marksdir" "$path")"

	local link="$(basename "$path")"

	(cd "$marksdir" && ln -svf "$target" "${link#.}")
}

# screenshots
# uploads : goto $HOME/.uploads
# upload : uploads text files with wgetpaste or image files with imgur
#   wgetpaste (rotate service/language/expiration) and copy link
#   file is created in .uploads
#     filepath_URL_expdate
# open_upload
#     if curl returns 200, then restore/copy/open it
#     else delete and reupload

# ?? WTF IS THIS??
BINDS[attach]=alt-f
DESCS[attach]='Select entry'
attach() {
	local path="$(path "$1")"
	mkdir -p "$HOME/.selections"
	ln -svf "$path" "$HOME/.selections"
}

BINDS[marks]=alt-space
DESCS[marks]='Go to marks directory'
marks() {
	save_opt hide
	set_opt hide 0
	folder_cd "$HOME/.marks"
}

BINDS[home]=alt-q
DESCS[home]='Home directory'
home() {
	folder_cd "$HOME"
}

BINDS[add]=alt-a
DESCS[add]='Create directory'
add() {
	local query="$2"
	folder_restore
	mkdir -p "$FOLDER/$query"
}

BINDS[del]=alt-d
DESCS[del]='Delete entry definitively'
del() {
	rm -rf "$(path "$1")"
}

BINDS[open]=tab
HOOKS[open]=noclear
DESCS[open]='Open entry'
open() {
	command open "$(path "$1")"
}

BINDS[_open]=alt-enter
HOOKS[_open]=accept
DESCS[_open]='Open entry and quit'
_open() {
	open "$1"
}

BINDS[vimsession]=alt-u
HOOKS[vimsession]=accept
DESCS[vimsession]='Open vim project and quit'
vimsession() {
	command open "$(path "$1")" nvim
}

BINDS[enter]=enter
DESCS[enter]='Change Directory'
enter() {
  local entry="$1"

	folder_cd "${entry%/*}"
}

BINDS[back]=esc
DESCS[back]='Parent Directory'
back() {
	folder_cd ..
}

atfinish() {
	#unset_opt pwd
	unset_opt hide
	unset_opt mode
  unset_opt save
  unset_opt path
  unset_opt out
  unset_opt mult
  unset_opt dir
}
